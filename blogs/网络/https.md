---
title: https
date: 2020-08-29
tags:
  - 网络
categories:
  - 网络基础
---

### 不使用 SSL/TLS 的 HTTP 通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

+ `窃听风险（eavesdropping）`：第三方可以获知通信内容。
+ `篡改风险（tampering）`：第三方可以修改通信内容。
+ `冒充风险（pretending）`：第三方可以冒充他人身份参与通信。

### SSL/TLS 协议是为了解决这三大风险而设计的，希望达到：

+ 所有信息都是`加密传播`，第三方无法窃听。
+ 具有`校验机制`，一旦被篡改，通信双方会立刻发现。
+ 配备`身份证书`，防止身份被冒充。

### 问题

1. 如何保证公钥不被篡改？
   > 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
2. 公钥加密计算量太大，如何减少耗用的时间？
   > 解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

### SSL/TLS 协议的基本过程

1. 客户端向服务器端索要并验证公钥。
2. 双方协商生成"对话密钥"。
3. 双方采用"对话密钥"进行加密通信。

### 连接过程（握手阶段： 即为上述基本过程中的前两步）

1. step1,客户端发出请求（clientHello）
::: tip
  + 支持的协议版本，比如 TLS 1.0 版。
  + 一个客户端生成的随机数，稍后用于生成"对话密钥"。
  + 支持的加密方法，比如 RSA 公钥加密。
  + 支持的压缩方法。
:::

2. step2,服务器回应（SeverHello）
::: tip
  + 确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
  + 一个服务器生成的随机数，稍后用于生成"对话密钥"。
  + 确认使用的加密方法，比如 RSA 公钥加密。
  + 服务器证书。
:::

3. step3,客户端回应
::: tip
  + 一个随机数。该随机数用服务器公钥加密，防止被窃听。
  + 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
  + 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验。
:::

4. step4,服务器的最后回应
::: tip
  + 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
  + 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。
:::

### 上述步骤可以简述为：
1. 客户端给出`协议版本号`、一个客户端生成的`随机数（Client random）`，以及客户端支持的`加密方法`。

2. 服务端确认双方使用的`加密方法`，并给出`数字证书`(此处提供加密最后一个随机数的公钥)、以及一个服务器生成的`随机数（Server random）`。

3. 客户端确认数字证书有效，然后生成一个新的`随机数（Premaster secret）`，并使用数字证书中的公钥，`加密这个随机数`，发给服务端。

4. 服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。

5. 客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

### 握手阶段的三点注意
1. 生成对话密钥一共需要三个随机数。
2. 握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
3. 服务器公钥放在服务器的`数字证书`之中。

### 数字证书是什么
![avator](/https.awebp)

#### session的恢复
+ 握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。
+ 这时有两种方法可以恢复原来的session：一种叫做`session ID`，另一种叫做`session ticket`。
+ session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。
+ session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。
+ 客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。