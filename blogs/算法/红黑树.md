---
title: 红黑树
date: 2022-06-14
tags:
  - 算法基础
categories:
  - 算法基础
---

## 红黑树

### 特性
红黑树是一种自平衡的二叉查找树，除了符合二叉查找树的基本特性外，它还具有下列附加特性：
1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点都是黑色的空节点（NIL节点）。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

>一棵典型的红黑树如下：

![avator](/normal-red-black.awebp)

### 向上述红黑树种插入元素的两种情况
1. 向原红黑树插入值为14的新节点：
![avator](/b-a-14.awebp)
2. 向原红黑树插入值为21的新节点：
![avator](/b-a-21.awebp)


当我们插入元素时，红黑树的平衡可能会被打破，此时我们就需要对红黑树做出调整了，
调整策略如下：
1. 变色
- 下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：
![avator](/change-color/1.awebp)
- 但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：
![avator](/change-color/2.awebp)
- 此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：
![avator](/change-color/3.awebp)
2. 旋转
- 左旋转
> 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：

![avator](/rotate/left.awebp)
:::tip
图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。
:::

- 右旋转
> 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：

![avator](/rotate/right.awebp)
:::tip
图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。
:::

### 步骤详解
3. 以上述案例继续讨论
- 首先，我们需要做的是变色，把节点25及其下方的节点变色：
![avator](/step/1.awebp)
:::tip
 此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。
:::
+ 变色已无法解决问题，我们把节点13看做X，把节点17看做Y，像刚才的示意图那样进行左旋转：
![avator](/step/2.awebp)
![avator](/step/3.awebp)
![avator](/step/4.awebp)
+ 由于根节点必须是黑色节点，所以需要变色，变色结果如下：
![avator](/step/5.awebp)
:::tip
 这样就结束了吗？并没有。因为其中两条路径(17 -> 8 -> 6 -> NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。
:::
+ 这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行右旋转：
![avator](/step/6.awebp)
![avator](/step/7.awebp)
![avator](/step/8.awebp)
+ 最后根据规则来进行变色：
![avator](/step/9.awebp)
:::tip
如此一来，我们的红黑树变得重新符合规则。这一个例子的调整过程比较复杂，经历了如下步骤：
<br/>变色 -> 左旋转 -> 变色 -> 右旋转 -> 变色
:::

