---
title: 排序算法
date: 2020-09-04
tags:
  - 算法基础
categories:
  - 算法基础
---

### 堆排序

例如需要排序的数组为[3,2,3,1,2,4,5,5,6]
特点

- 第 n 个元素的 左子节点 为 `2*n+1`
- 第 n 个元素的 右子节点 为 `2*n+2`
- 第 n 个元素的 父节点 为 `Math.floor((n-1)/2)`
- 最后一个非叶子节点为 `Math.floor(arr.length/2)-1`
  :::tip
  实现堆排序（一般多使用与求最大的几个元素或最小的几个元素，或最大的前几个元素，最小的前几个元素时使用）
  :::
  ![avator](/hamp.png)

```js
// 交换元素
const swap = function(arr, i, j) {
	const temp = arr[i];
	arr[i] = arr[j];
	arr[j] = temp;
};

// 调整大根堆元素
const adjustHeap = function(arr, i, heapSize) {
	let l = 2 * i + 1, // 左支元素
		r = 2 * i + 2, // 右支元素
		largest = i;
	if (l < heapSize && arr[l] > arr[largest]) {
		largest = l;
	}
	if (r < heapSize && arr[r] > arr[largest]) {
		largest = r;
	}
	if (largest !== i) {
		swap(arr, largest, i);
		adjustHeap(arr, largest, heapSize);
	}
};

// 构建大根堆
const buildHeap = function(arr, heapSize) {
	// 最后一个非叶子节点
	for (let index = Math.floor(heapSize / 2) - 1; index > -1; index--) {
		adjustHeap(arr, index, heapSize);
	}
};

// 排序
const heapSortFn = function(arr) {
	let heapSize = arr.length;
	buildHeap(arr, heapSize); // 第一次构建时需要全局调整
	while (heapSize > 1) {
		swap(arr, 0, heapSize - 1);
		heapSize--;
		adjustHeap(arr, 0, heapSize); // 后续操作不需要全局调整，只有交换后的那个元素需要重新调整
	}
	return arr;
};

const arr = [3, 2, 3, 1, 2, 4, 5, 5, 6];
heapSortFn(arr);
console.log(arr);
```
