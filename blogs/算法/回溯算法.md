---
title: 回溯算法
date: 2020-08-09
tags:
 - 算法基础
categories: 
 - 算法基础
---
### 回溯剪枝过程
1. 组合总和 
::: tip
给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。
candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 
对于给定的输入，保证和为 target 的唯一组合数少于 150 个。
 例子： 
+ 输入: candidates = [2,3,6,7], target = 7,
输出: [[7],[2,2,3]]
+ 输入: candidates = [2], target = 1,
输出: []
:::
题解： 
``` js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b);
    if (candidates[0] > target) return [];
    const arr = [], len = candidates.length;
    const dfs = function (target, innerArr, lastIndex) {
        if (target < 0) {
            return;
        }
        if (target === 0) {
            arr.push(innerArr.slice());
            return;
        }
        for(let i =lastIndex; i<len; i++) {
            const currentVal = candidates[i];
            innerArr.push(currentVal);
            dfs(target-currentVal, innerArr, i);
            innerArr.pop();
        }
        
    }
    dfs(target, [], 0);
    return arr;
};
```

图示：
![avator](/combine_1.png)


2. 组合总和Ⅱ
::: tip
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
注意：解集不能包含重复的组合。
:::
例子：
+ 输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
+ 输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]

``` js
var combinationSum2 = function (candidates, target) {
    candidates.sort((a, b) => a - b);
    if (candidates[0] > target) return [];
    const arr = [],
        len = candidates.length;
    let lastVal = 0;
    const dfs = function (target, innerArr, index) {
        if (target === 0) {
            arr.push(innerArr.slice());
            return;
        }
        if (target < 0) {
            return;
        }
        for (let i = index; i < len; i++) {
            if (candidates[i] === lastVal) continue; // 子树整个的剪掉
            const currentVal = candidates[i];
            innerArr.push(currentVal);
            dfs(target - currentVal, innerArr, i + 1);
            lastVal = innerArr.pop(); // 获取for循环的上一轮取值
        }
    }
    dfs(target, [], 0);
    return arr;
};
```

图示：
![avator](/combine_2.png)