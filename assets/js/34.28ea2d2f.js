(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{517:function(s,v,_){"use strict";_.r(v);var t=_(4),e=Object(t.a)({},(function(){var s=this,v=s.$createElement,_=s._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[_("h3",{attrs:{id:"不使用-ssl-tls-的-http-通信，就是不加密的通信。所有信息明文传播，带来了三大风险。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不使用-ssl-tls-的-http-通信，就是不加密的通信。所有信息明文传播，带来了三大风险。"}},[s._v("#")]),s._v(" 不使用 SSL/TLS 的 HTTP 通信，就是不加密的通信。所有信息明文传播，带来了三大风险。")]),s._v(" "),_("ul",[_("li",[_("code",[s._v("窃听风险（eavesdropping）")]),s._v("：第三方可以获知通信内容。")]),s._v(" "),_("li",[_("code",[s._v("篡改风险（tampering）")]),s._v("：第三方可以修改通信内容。")]),s._v(" "),_("li",[_("code",[s._v("冒充风险（pretending）")]),s._v("：第三方可以冒充他人身份参与通信。")])]),s._v(" "),_("h3",{attrs:{id:"ssl-tls-协议是为了解决这三大风险而设计的，希望达到："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls-协议是为了解决这三大风险而设计的，希望达到："}},[s._v("#")]),s._v(" SSL/TLS 协议是为了解决这三大风险而设计的，希望达到：")]),s._v(" "),_("ul",[_("li",[s._v("所有信息都是"),_("code",[s._v("加密传播")]),s._v("，第三方无法窃听。")]),s._v(" "),_("li",[s._v("具有"),_("code",[s._v("校验机制")]),s._v("，一旦被篡改，通信双方会立刻发现。")]),s._v(" "),_("li",[s._v("配备"),_("code",[s._v("身份证书")]),s._v("，防止身份被冒充。")])]),s._v(" "),_("h3",{attrs:{id:"问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[s._v("#")]),s._v(" 问题")]),s._v(" "),_("ol",[_("li",[s._v("如何保证公钥不被篡改？\n"),_("blockquote",[_("p",[s._v("解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。")])])]),s._v(" "),_("li",[s._v("公钥加密计算量太大，如何减少耗用的时间？\n"),_("blockquote",[_("p",[s._v('解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。')])])])]),s._v(" "),_("h3",{attrs:{id:"ssl-tls-协议的基本过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls-协议的基本过程"}},[s._v("#")]),s._v(" SSL/TLS 协议的基本过程")]),s._v(" "),_("ol",[_("li",[s._v("客户端向服务器端索要并验证公钥。")]),s._v(" "),_("li",[s._v('双方协商生成"对话密钥"。')]),s._v(" "),_("li",[s._v('双方采用"对话密钥"进行加密通信。')])]),s._v(" "),_("h3",{attrs:{id:"连接过程（握手阶段：-即为上述基本过程中的前两步）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连接过程（握手阶段：-即为上述基本过程中的前两步）"}},[s._v("#")]),s._v(" 连接过程（握手阶段： 即为上述基本过程中的前两步）")]),s._v(" "),_("ol",[_("li",[s._v("step1,客户端发出请求（clientHello）")])]),s._v(" "),_("div",{staticClass:"custom-block tip"},[_("ul",[_("li",[s._v("支持的协议版本，比如 TLS 1.0 版。")]),s._v(" "),_("li",[s._v('一个客户端生成的随机数，稍后用于生成"对话密钥"。')]),s._v(" "),_("li",[s._v("支持的加密方法，比如 RSA 公钥加密。")]),s._v(" "),_("li",[s._v("支持的压缩方法。")])])]),s._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[s._v("step2,服务器回应（SeverHello）")])]),s._v(" "),_("div",{staticClass:"custom-block tip"},[_("ul",[_("li",[s._v("确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。")]),s._v(" "),_("li",[s._v('一个服务器生成的随机数，稍后用于生成"对话密钥"。')]),s._v(" "),_("li",[s._v("确认使用的加密方法，比如 RSA 公钥加密。")]),s._v(" "),_("li",[s._v("服务器证书。")])])]),s._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[s._v("step3,客户端回应")])]),s._v(" "),_("div",{staticClass:"custom-block tip"},[_("ul",[_("li",[s._v("一个随机数。该随机数用服务器公钥加密，防止被窃听。")]),s._v(" "),_("li",[s._v("编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。")]),s._v(" "),_("li",[s._v("客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验。")])])]),s._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[s._v("step4,服务器的最后回应")])]),s._v(" "),_("div",{staticClass:"custom-block tip"},[_("ul",[_("li",[s._v("编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。")]),s._v(" "),_("li",[s._v("服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。")])])]),s._v(" "),_("h3",{attrs:{id:"上述步骤可以简述为："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#上述步骤可以简述为："}},[s._v("#")]),s._v(" 上述步骤可以简述为：")]),s._v(" "),_("ol",[_("li",[_("p",[s._v("客户端给出"),_("code",[s._v("协议版本号")]),s._v("、一个客户端生成的"),_("code",[s._v("随机数（Client random）")]),s._v("，以及客户端支持的"),_("code",[s._v("加密方法")]),s._v("。")])]),s._v(" "),_("li",[_("p",[s._v("服务端确认双方使用的"),_("code",[s._v("加密方法")]),s._v("，并给出"),_("code",[s._v("数字证书")]),s._v("(此处提供加密最后一个随机数的公钥)、以及一个服务器生成的"),_("code",[s._v("随机数（Server random）")]),s._v("。")])]),s._v(" "),_("li",[_("p",[s._v("客户端确认数字证书有效，然后生成一个新的"),_("code",[s._v("随机数（Premaster secret）")]),s._v("，并使用数字证书中的公钥，"),_("code",[s._v("加密这个随机数")]),s._v("，发给服务端。")])]),s._v(" "),_("li",[_("p",[s._v("服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。")])]),s._v(" "),_("li",[_("p",[s._v('客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。')])])]),s._v(" "),_("h3",{attrs:{id:"握手阶段的三点注意"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#握手阶段的三点注意"}},[s._v("#")]),s._v(" 握手阶段的三点注意")]),s._v(" "),_("ol",[_("li",[s._v("生成对话密钥一共需要三个随机数。")]),s._v(" "),_("li",[s._v('握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。')]),s._v(" "),_("li",[s._v("服务器公钥放在服务器的"),_("code",[s._v("数字证书")]),s._v("之中。")])]),s._v(" "),_("h3",{attrs:{id:"数字证书是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数字证书是什么"}},[s._v("#")]),s._v(" 数字证书是什么")]),s._v(" "),_("p",[_("img",{attrs:{src:"/https.awebp",alt:"avator"}})]),s._v(" "),_("h4",{attrs:{id:"session的恢复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#session的恢复"}},[s._v("#")]),s._v(" session的恢复")]),s._v(" "),_("ul",[_("li",[s._v("握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。")]),s._v(" "),_("li",[s._v("这时有两种方法可以恢复原来的session：一种叫做"),_("code",[s._v("session ID")]),s._v("，另一种叫做"),_("code",[s._v("session ticket")]),s._v("。")]),s._v(" "),_("li",[s._v('session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。')]),s._v(" "),_("li",[s._v("session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。")]),s._v(" "),_("li",[s._v("客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。")])])])}),[],!1,null,null,null);v.default=e.exports}}]);